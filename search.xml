<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线性结构-稀疏数组</title>
    <url>/2021/02/16/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="线性结构-稀疏数组"><a href="#线性结构-稀疏数组" class="headerlink" title="线性结构-稀疏数组"></a>线性结构-稀疏数组</h1><p>数据结构包括：<strong>线性结构</strong>和<strong>非线性结构</strong>。</p>
<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>线性结构见的有：组队列、链表和栈</li>
</ol>
<h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p>
<p>今天我们的主角是线性结构中的<code>稀疏数组</code>,今天讲解一下什么是稀疏数组，稀疏数组什么时候该用，以及怎么用。</p>
<h2 id="什么是稀疏数组"><a href="#什么是稀疏数组" class="headerlink" title="什么是稀疏数组"></a>什么是稀疏数组</h2><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。用于减少存放这些数据使用的空间。</p>
<p>稀疏数组的处理方法是:</p>
<p>1)记录数组一共有几行几列，有多少个不同的值</p>
<p>2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<p>用图说话：</p>
<p>原数组：（有很多0，这个时候可以选择稀疏数组进行压缩空间）</p>
<p><img src="https://i.loli.net/2021/02/16/y3WpCs6dKjVoMlv.png" alt="image.png"></p>
<p>稀疏数组：（第一行分别代表有6行，7列，以及有8个值，最终构成一个3列（8+1）行的二维数组）</p>
<p><img src="https://i.loli.net/2021/02/16/fZULtknmoxy4z6l.png" alt="image.png"></p>
<h2 id="稀疏数组怎么用"><a href="#稀疏数组怎么用" class="headerlink" title="稀疏数组怎么用"></a>稀疏数组怎么用</h2><p><img src="https://i.loli.net/2021/02/16/TmJCxNS5bVlgHPw.png" alt="image.png"></p>
<p>代码实现：原数组是一个11*11的二维数组</p>
<p><code>生成稀疏数组</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 生成稀疏数组</span><br><span class="line"> * @param cheeseArr</span><br><span class="line"> * @param sum</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int[][] generateSparseArray(int[][] cheeseArr, int sum) &#123;</span><br><span class="line">    &#x2F;&#x2F;2.创建对应的稀疏数组  一个3列 （非0项数字出现次数和+1）行 （多了一个统计原始数组行列和所有非0项出现次数和的行） 数组</span><br><span class="line">    int sparseArr[][] &#x3D; new int[sum +1][3];</span><br><span class="line">    &#x2F;&#x2F;给数组赋值</span><br><span class="line">    sparseArr[0][0] &#x3D; 11; &#x2F;&#x2F;行</span><br><span class="line">    sparseArr[0][1] &#x3D; 11; &#x2F;&#x2F;列</span><br><span class="line">    sparseArr[0][2] &#x3D; sum; &#x2F;&#x2F;有效值个数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;便利二维数组，将非0值遍历到稀疏数组</span><br><span class="line">    &#x2F;&#x2F;定义一个计数器，记录是第几个数</span><br><span class="line">    int count  &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; cheeseArr.length; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; cheeseArr[i].length; j++) &#123;</span><br><span class="line">            if(cheeseArr[i][j]!&#x3D;0) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sparseArr[count][0] &#x3D; i; &#x2F;&#x2F;行</span><br><span class="line">                sparseArr[count][1] &#x3D; j; &#x2F;&#x2F;列</span><br><span class="line">                sparseArr[count][2] &#x3D; cheeseArr[i][j]; &#x2F;&#x2F;值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;输出稀疏数组</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(&quot;得到的稀疏数组为:&quot;);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">        System.out.printf(&quot;%d\t %d\t %d\t&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    return sparseArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>解析稀疏数组</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 通过稀疏数组还原原数组</span><br><span class="line">     * 思路：先读取第一行数据，创建原始的二维数组</span><br><span class="line">     * 读取稀疏数组后几行数据并赋值给原始的二维数组即可</span><br><span class="line">     * @param sparseArr</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int[][] getOriginArr(int[][] sparseArr)&#123;</span><br><span class="line">        int[][] originArray &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            originArray[sparseArr[i][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原始数组为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; originArray.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; originArray[i].length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,originArray[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return originArray;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package top.ryan.sparsearray;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 稀疏数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个原始的二维数组11*11</span><br><span class="line">        &#x2F;&#x2F;0-》没有棋子 1-》黑子 2-》蓝子</span><br><span class="line">        int cheeseArr[][] &#x3D; new int[11][11];</span><br><span class="line">        cheeseArr[1][2] &#x3D; 1;</span><br><span class="line">        cheeseArr[2][3] &#x3D; 2;</span><br><span class="line">        cheeseArr[3][3] &#x3D; 1;</span><br><span class="line">        cheeseArr[4][5] &#x3D; 2;</span><br><span class="line">        &#x2F;&#x2F;输出原始数组</span><br><span class="line">        for (int[] arr : cheeseArr) &#123;</span><br><span class="line">            for (int num : arr) &#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,num);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将二维数组转为稀疏数组</span><br><span class="line">        &#x2F;&#x2F;1.先便利二维数组，得到非0数组的个数</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; cheeseArr.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cheeseArr[i].length; j++) &#123;</span><br><span class="line">                if(cheeseArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[][] sparseArr &#x3D; generateSparseArray(cheeseArr, sum);</span><br><span class="line">        &#x2F;&#x2F;从稀疏数组还原原始数组</span><br><span class="line">        int[][] originArr &#x3D; getOriginArr(sparseArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成稀疏数组</span><br><span class="line">     * @param cheeseArr</span><br><span class="line">     * @param sum</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static int[][] generateSparseArray(int[][] cheeseArr, int sum) &#123;</span><br><span class="line">        &#x2F;&#x2F;2.创建对应的稀疏数组  一个3列 （非0项数字出现次数和+1）行 （多了一个统计原始数组行列和所有非0项出现次数和的行） 数组</span><br><span class="line">        int sparseArr[][] &#x3D; new int[sum +1][3];</span><br><span class="line">        &#x2F;&#x2F;给数组赋值</span><br><span class="line">        sparseArr[0][0] &#x3D; 11; &#x2F;&#x2F;行</span><br><span class="line">        sparseArr[0][1] &#x3D; 11; &#x2F;&#x2F;列</span><br><span class="line">        sparseArr[0][2] &#x3D; sum; &#x2F;&#x2F;有效值个数</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;便利二维数组，将非0值遍历到稀疏数组</span><br><span class="line">        &#x2F;&#x2F;定义一个计数器，记录是第几个数</span><br><span class="line">        int count  &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; cheeseArr.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cheeseArr[i].length; j++) &#123;</span><br><span class="line">                if(cheeseArr[i][j]!&#x3D;0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] &#x3D; i; &#x2F;&#x2F;行</span><br><span class="line">                    sparseArr[count][1] &#x3D; j; &#x2F;&#x2F;列</span><br><span class="line">                    sparseArr[count][2] &#x3D; cheeseArr[i][j]; &#x2F;&#x2F;值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出稀疏数组</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;得到的稀疏数组为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t %d\t %d\t&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return sparseArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过稀疏数组还原原数组</span><br><span class="line">     * 思路：先读取第一行数据，创建原始的二维数组</span><br><span class="line">     * 读取稀疏数组后几行数据并赋值给原始的二维数组即可</span><br><span class="line">     * @param sparseArr</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int[][] getOriginArr(int[][] sparseArr)&#123;</span><br><span class="line">        int[][] originArray &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            originArray[sparseArr[i][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;原始数组为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; originArray.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; originArray[i].length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,originArray[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return originArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	1	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line"></span><br><span class="line">得到的稀疏数组为:</span><br><span class="line">11	 11	 4	</span><br><span class="line">1	 2	 1	</span><br><span class="line">2	 3	 2	</span><br><span class="line">3	 3	 1	</span><br><span class="line">4	 5	 2	</span><br><span class="line">原始数组为:</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	1	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性结构-队列</title>
    <url>/2021/02/18/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="线性结构-队列"><a href="#线性结构-队列" class="headerlink" title="线性结构-队列"></a>线性结构-队列</h1><p>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</p>
<p>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p>
<p>使用数组模拟队列示意图</p>
<p><img src="https://i.loli.net/2021/02/17/2JuWlZzhMgNGYnx.png" alt="image.png"></p>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>​        队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。</p>
<p>​     因为队列的输出、输入是分别从前后端来处理，因此需要两个变<strong>量</strong> <strong>front**</strong>及** <strong>rear**</strong>分别记录队列前后端**的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变</p>
<p><img src="https://i.loli.net/2021/02/17/yVlDkTzdxcFAL2h.png" alt="image.png"></p>
<p>模拟队列思路：</p>
<p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：<strong>思**</strong>路分析** </p>
<p>1)将尾指针往后移：rear+1 , 当front == rear 【空】</p>
<p>2)若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ArrayQueue(arrMaxSize: Int) &#123; val maxSize: Int &#x3D; arrMaxSize</span><br><span class="line">  val array &#x3D; new Array[Int](arrMaxSize)</span><br><span class="line">  var front: Int &#x3D; -1</span><br><span class="line">  var rear: Int &#x3D; -1</span><br><span class="line">&#125;</span><br><span class="line">rear 是队列最后[含]</span><br><span class="line">front 是队列最前元素[不含]</span><br></pre></td></tr></table></figure>
<p>Ø出队列操作popQueue</p>
<p>入队列操作addQueue</p>
<p>Ø显示队列的情况showQueue</p>
<p>Ø查看队列头元素<strong>head</strong>Queue</p>
<p>代码实现数组模拟队列：(初始代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Queue&#123;</span><br><span class="line">    &#x2F;&#x2F;队头</span><br><span class="line">    private int front;</span><br><span class="line">    &#x2F;&#x2F;队尾</span><br><span class="line">    private int rear;</span><br><span class="line">    &#x2F;&#x2F;初始化一个6个size的数组</span><br><span class="line">    private int[] arr;</span><br><span class="line">    private int maxSize;</span><br><span class="line"></span><br><span class="line">    public Queue(int size)&#123;</span><br><span class="line">        if (size&lt;1)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;数组大小不能小于1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        maxSize &#x3D; size;</span><br><span class="line">        arr &#x3D; new int[maxSize];</span><br><span class="line">        front &#x3D; -1;</span><br><span class="line">        rear &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队尾添加数字,如果rear&lt;size-1就可以继续添加，不然</span><br><span class="line">     * @param num</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addQueue(int num)&#123;</span><br><span class="line">        if (isFull())&#123;</span><br><span class="line">            System.out.println(&quot;队列已满，不能添加&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear+1] &#x3D; num;</span><br><span class="line">        rear++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 弹出队头</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int popQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空，不能弹出队列&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int headNum &#x3D; arr[front+1];</span><br><span class="line">        front++;</span><br><span class="line">        System.out.println(&quot;弹出元素: &quot;+headNum);</span><br><span class="line">        return headNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队列</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; front+1 ; i &lt;&#x3D; rear; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t&quot;,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队头</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void headQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;队头元素:&quot;+arr[front+1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队尾</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void rearQueue()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;队尾元素:&quot;+arr[rear]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否满 队尾&#x3D;maxsize-1</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        if (rear&#x3D;&#x3D;maxSize-1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否时空的 队尾&#x3D;队头&#x3D;-1则为空</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        if(front&#x3D;&#x3D;rear)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue queue &#x3D; new Queue(5);</span><br><span class="line">        queue.addQueue(1);</span><br><span class="line">        queue.addQueue(2);</span><br><span class="line">        queue.addQueue(3);</span><br><span class="line">        queue.addQueue(4);</span><br><span class="line">        queue.addQueue(5);</span><br><span class="line">        queue.showQueue();</span><br><span class="line">        queue.headQueue();</span><br><span class="line">        queue.rearQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.showQueue();</span><br><span class="line">        queue.headQueue();</span><br><span class="line">        queue.rearQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">        queue.popQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	2	3	4	5	</span><br><span class="line">队头元素:1</span><br><span class="line">队尾元素:5</span><br><span class="line">弹出元素: 1</span><br><span class="line">2	3	4	5	</span><br><span class="line">队头元素:2</span><br><span class="line">队尾元素:5</span><br><span class="line">弹出元素: 2</span><br><span class="line">弹出元素: 3</span><br><span class="line">弹出元素: 4</span><br><span class="line">弹出元素: 5</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 队列为空，不能弹出队列</span><br></pre></td></tr></table></figure>
<p>可以看到，基本能完成队列的功能，但是有问题，<code>数组不能复用</code>，空间满了就不能继续添加了，现在进行优化，使用数组模拟环形队列，解决数组不能复用的问题。</p>
<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><p>使用数组模拟环形队列思路：</p>
<p><img src="https://i.loli.net/2021/02/17/yVlDkTzdxcFAL2h.png" alt="image.png"></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用数组实现环形队列 ：用以实现数组复用</span><br><span class="line"> * 这里做了2个调整：front指向第一个元素所在位置  rear指向最后一个元素所在位置</span><br><span class="line"> * 数组中有效个数为：(rear + maxsize - front) % maxsize</span><br><span class="line"> *&#x2F;</span><br><span class="line">class CircleQueue&#123;</span><br><span class="line">    &#x2F;&#x2F;第一个元素所在位置</span><br><span class="line">    private int front;</span><br><span class="line">    &#x2F;&#x2F;最后一个元素所在位置</span><br><span class="line">    private int rear;</span><br><span class="line">    &#x2F;&#x2F;最大容量</span><br><span class="line">    private int maxsize;</span><br><span class="line">    &#x2F;&#x2F;数组</span><br><span class="line">    private int[] arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化环形队列</span><br><span class="line">     * @param size 最大容量</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public CircleQueue(int size)&#123;</span><br><span class="line">        front &#x3D; 0; &#x2F;&#x2F;第一个位置</span><br><span class="line">        rear &#x3D; 0; &#x2F;&#x2F;最开始也为0</span><br><span class="line">        maxsize &#x3D; size;</span><br><span class="line">        arr &#x3D; new int[maxsize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加队列元素</span><br><span class="line">     * @param num</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addQueue(int num)&#123;</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列已满，不能添加数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear] &#x3D; num;</span><br><span class="line">        rear &#x3D; (rear+1)%maxsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 取出数据</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int popQueue()&#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int num &#x3D; arr[front];</span><br><span class="line">        front &#x3D; (front+1)%maxsize;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示队列,front是会不断累加的会有溢出，需要取模</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showQueue()&#123;</span><br><span class="line">        if (isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; front; i &lt; front+getSize(); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d] &#x3D; %d \t&quot;,i%maxsize,arr[i%maxsize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否为空： 判断条件 front  &#x3D; rear</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return rear &#x3D;&#x3D; front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 队列是否满：条件 （rear + 1）%maxsize &#x3D; front;eg:rear&#x3D;9,maxsize&#x3D;10,front&#x3D;0,数组下标最大就为9，9+1%10 &#x3D;0 &#x3D; front</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">         return (rear+1)%maxsize&#x3D;&#x3D;front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取队列有效个数</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return (maxsize + rear - front)%maxsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
</search>
